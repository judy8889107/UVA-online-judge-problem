## 題目意思<br>
給一長度為 n 的數列與一數 k，問在數列的相鄰兩數之間插入 '+' 或 '-'
<br>是否存在一運算法使得整個運算結果能夠被 k 整除。(1 <= n <= 10000, 2 <= k <= 100)
## 解題<br>
<br>這題偏難，利用題目預設測資 
<br>2
<br>4 7
<br>17 5 -21 15
<br>4 5
<br>17 5 -21 15
<br>先看第一筆測資,m=4, k=7(除數), num=17,5,-21,15
<br>(17±5±-21±15) % 7 可以看成 ((17%7) + (5%7) + (-21%7) + (15%7)) % 7
```cpp
	//輸入m個數字，並將他們除以k的餘數算出
	for(int i=0;i<n;i++){
		cin >> num[i];
		num[i] = abs(num[i])%k;
	}
```
<br>利用array去紀錄，這個部分比較難理解：
<br>**利用f去紀錄時，要宣告在global變數，因為n有可能等於10000**
<br>**先在輸入每筆測資後，利用memset() function去清空f [ ] [ ]：**

```cpp
#include<string.h>

memset(f,0,sizeof(f));
```
<br>利用array去紀錄：
```cpp
	f[0][0] = 1;
	//The f[n+1] record i-th num[]
	//The [100] is record the reminder of num[i]/k, Why 100 because the k is from 2~100
	//So the reminder of any integer divides k is less than 100
	for(int i=0;i<n;i++){ 
		for(int j=0;j<k;j++){
			if(f[i][j]){
				f[i+1][(j+k+num[i])%k] = 1;
				f[i+1][(j+k-num[i])%k] = 1;
				
			}
		}
	}
```
<br>一開始設定f[0][0]=1，從i=0開始，帶入公式
<br>**※為何要j+k再±num[i](餘數)，因有可能j-num[i]<0，因此要再加上k讓其最後%k的數字為正**
<br>**f[m+1][100] //100是因為題目設定除數最大就是100，因此餘數範圍介於0~99之間**

<br><br>**17%7=3, 5%7=5, -21%7=0, 15%7=1**
<br><br>**i=0,j=0 (f[0][0]=1成立)**
> <br>(0+7+3) % 7 = 3  **//f[1(i+1)][3] = 1**
> <br>(0+7-3) % 7 = 4  **//f[1(i+1)][4] = 1**

<br>**i=0, j=1 (f[0][1]!=1不成立)**
<br>下面的就不會執行
> <br>(1+7+3) % 7 = 3
> <br>(1+7+3) % 7 = 3

<br>**i=1, j=0**
<br>**i=1, j=1**
<br>**i=1, j=2**
<br>**i=1, j=3 f[1][3]=1**
> <br>(3+7+5) % 7 = 1  **//f[2(i+1)][1] = 1**
> <br>(3+7-5) % 7 = 5  **//f[2(i+1)][5] = 1**

<br>**i=1, j=4 f[1][4]=1**
> <br>(4+7+5) % 7 = 2  **//f[2(i+1)][2] = 1**
> <br>(4+7-5) % 7 = 6  **//f[2(i+1)][6] = 1**

<br>依此類推，就是把第i-th / 7 的餘數± i+1-th / 7的餘數記錄下來
<br>若最後f[m][0] = 1則代表所有數字隨意帶入±的結果可以整除k(divisible) 
